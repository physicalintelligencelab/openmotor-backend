<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenMotor Research Tools Suite</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f7fa;
            color: #2c3e50;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px 0;
            text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            margin-bottom: 40px;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .workspace {
            background: white;
            border-radius: 12px;
            padding: 40px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            min-height: 500px;
        }

        .workspace-header {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid #e2e8f0;
        }

        .workspace-title {
            font-size: 1.8rem;
            color: #2c3e50;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #4a5568;
        }

        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
            width: 100%;
        }

        .file-input {
            position: absolute;
            left: -9999px;
        }

        .file-input-label {
            display: block;
            padding: 12px 16px;
            background: #f7fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-input-label:hover {
            background: #edf2f7;
            border-color: #a0aec0;
        }

        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            width: 100%;
            justify-content: center;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 18px;
            padding: 16px;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #4a5568;
            width: auto;
            padding: 10px 20px;
            font-size: 14px;
            margin-top: 10px;
        }

        .btn-secondary:hover {
            background: #cbd5e0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: width 0.3s ease;
        }

        .status-message {
            padding: 15px 20px;
            border-radius: 8px;
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-info {
            background: #e6fffa;
            color: #047481;
            border: 1px solid #81e6d9;
        }

        .status-success {
            background: #e6ffed;
            color: #22543d;
            border: 1px solid #9ae6b4;
        }

        .status-error {
            background: #fff5f5;
            color: #742a2a;
            border: 1px solid #feb2b2;
        }

        .status-warning {
            background: #fffaf0;
            color: #7b341e;
            border: 1px solid #feb062;
        }

        .results-section {
            margin-top: 30px;
            padding-top: 30px;
            border-top: 2px solid #e2e8f0;
        }

        .results-title {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: #2c3e50;
        }

        .result-item {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .result-label {
            font-weight: 600;
            color: #4a5568;
            margin-bottom: 5px;
        }

        .result-value {
            color: #2c3e50;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .experiment-inputs {
            max-height: 300px;
            overflow-y: auto;
            margin-bottom: 20px;
        }

        .experiment-item {
            background: #f7fafc;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
        }

        .add-experiment-btn {
            width: 100%;
            padding: 10px;
            background: #f7fafc;
            border: 2px dashed #cbd5e0;
            border-radius: 8px;
            color: #4a5568;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
        }

        .add-experiment-btn:hover {
            background: #edf2f7;
            border-color: #a0aec0;
        }

        .remove-file {
            background: none;
            border: none;
            color: #e53e3e;
            cursor: pointer;
            font-size: 18px;
            float: right;
        }

        .hidden {
            display: none !important;
        }

        .pdf-options {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .pdf-option-btn {
            flex: 1;
            padding: 10px;
            border: 2px solid #e2e8f0;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: 600;
            color: #4a5568;
        }

        .pdf-option-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #667eea;
        }

        .pdf-option-btn:hover:not(.active) {
            background: #f7fafc;
            border-color: #cbd5e0;
        }

        .search-container {
            position: relative;
        }

        .search-input-wrapper {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .search-input {
            flex: 1;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
        }

        .search-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .search-btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .search-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .search-results {
            margin-top: 20px;
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }

        .paper-item {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
            cursor: pointer;
            transition: background 0.2s;
        }

        .paper-item:hover {
            background: #f7fafc;
        }

        .paper-item.selected {
            background: #e6f4ff;
            border-left: 4px solid #667eea;
        }

        .paper-title {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 5px;
        }

        .paper-authors {
            color: #718096;
            font-size: 14px;
            margin-bottom: 3px;
        }

        .paper-journal {
            color: #718096;
            font-size: 14px;
        }

        .paper-year {
            color: #667eea;
            font-weight: 600;
        }

        .selected-paper {
            background: #e6f4ff;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border: 2px solid #667eea;
        }

        .searching-message {
            text-align: center;
            padding: 40px;
            color: #718096;
        }

        .pdf-search-status {
            margin-top: 10px;
            padding: 10px;
            background: #f7fafc;
            border-radius: 6px;
            font-size: 14px;
        }

        .pdf-found {
            color: #22543d;
            background: #e6ffed;
            border: 1px solid #9ae6b4;
        }

        .pdf-not-found {
            color: #e53e3e;
            background: #fff5f5;
            border: 1px solid #feb2b2;
        }

        .api-key-section {
            background: #f7fafc;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border: 2px solid #e2e8f0;
        }

        .api-key-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 16px;
            margin-top: 10px;
        }

        .api-key-input:focus {
            outline: none;
            border-color: #667eea;
        }

        .api-key-note {
            font-size: 14px;
            color: #718096;
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="container">
            <h1>OpenMotor Complete Research Pipeline</h1>
            <p>Process all your motor learning research data in one go</p>
        </div>
    </div>

    <div class="container">
        <div class="workspace">
            <div class="workspace-header">
                <h2 class="workspace-title">üöÄ All-in-One Research Data Processor</h2>
            </div>
            
            <div id="main-form">
                <!-- API Key Section -->
                <div class="api-key-section">
                    <label class="form-label">üîë Anthropic API Key (Optional - using default if empty)</label>
                    <input 
                        type="password" 
                        id="custom-api-key" 
                        class="api-key-input" 
                        placeholder="sk-ant-api03-..."
                    >
                    <div class="api-key-note">
                        üí° Leave empty to use the default key. Only add your own if the default isn't working.
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Research Paper PDF</label>
                    <div class="pdf-options">
                        <button class="pdf-option-btn active" id="search-option" onclick="switchPdfOption('search')">
                            üîç Search for Paper
                        </button>
                        <button class="pdf-option-btn" id="upload-option" onclick="switchPdfOption('upload')">
                            üì§ Upload PDF
                        </button>
                    </div>

                    <div id="search-container" class="search-container">
                        <div class="search-input-wrapper">
                            <input 
                                type="text" 
                                class="search-input" 
                                id="search-input"
                                placeholder="Enter paper title, authors, or DOI..."
                                onkeypress="if(event.key === 'Enter') searchPapers()"
                            >
                            <button class="search-btn" id="search-btn" onclick="searchPapers()">
                                üîç Search
                            </button>
                        </div>
                        <div id="search-results-container"></div>
                        <div id="selected-paper-container"></div>
                    </div>

                    <div id="upload-container" class="hidden">
                        <div class="file-input-wrapper">
                            <input type="file" id="pdf-file" class="file-input" accept=".pdf">
                            <label for="pdf-file" class="file-input-label" id="pdf-label">
                                Click to select PDF file
                            </label>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label class="form-label">Experiment CSV Files (One per experiment)</label>
                    <div class="experiment-inputs" id="experiments-container">
                        <div class="experiment-item" data-exp-id="1">
                            <span style="font-weight: 600;">Experiment 1</span>
                            <div class="file-input-wrapper" style="margin-top: 10px;">
                                <input type="file" id="csv-1" class="file-input csv-input" accept=".csv" data-exp-id="1">
                                <label for="csv-1" class="file-input-label csv-label" data-exp-id="1">
                                    Click to select CSV file
                                </label>
                            </div>
                        </div>
                    </div>
                    <button class="add-experiment-btn" onclick="addExperiment()">
                        + Add Another Experiment
                    </button>
                </div>

                <button class="btn btn-primary" id="process-btn" onclick="processFiles()">
                    üöÄ Process All Files
                </button>

                <div class="progress-bar hidden" id="progress-container">
                    <div class="progress-fill" id="progress-bar" style="width: 0%"></div>
                </div>

                <div id="status-container"></div>
                <div id="results-container"></div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"></script>
    <script>
        // Configuration
        const API_URL = 'https://openmotor-backend.onrender.com';
        const DEFAULT_API_KEY = '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';
        
        let experimentCount = 1;
        let pdfFile = null;
        let csvFiles = {};
        let selectedPaper = null;
        let pdfOption = 'search';

        // Get API key (use custom if provided, otherwise default)
        function getApiKey() {
            const customKey = document.getElementById('custom-api-key').value.trim();
            return customKey || DEFAULT_API_KEY;
        }

        // Switch between search and upload
        function switchPdfOption(option) {
            pdfOption = option;
            document.getElementById('search-option').classList.toggle('active', option === 'search');
            document.getElementById('upload-option').classList.toggle('active', option === 'upload');
            
            // Properly hide/show containers
            if (option === 'search') {
                document.getElementById('search-container').classList.remove('hidden');
                document.getElementById('upload-container').classList.add('hidden');
            } else {
                document.getElementById('search-container').classList.add('hidden');
                document.getElementById('upload-container').classList.remove('hidden');
            }
        }

        // Enhanced paper search with multiple sources
        async function searchPapers() {
            const query = document.getElementById('search-input').value.trim();
            if (!query) {
                showStatus('warning', 'Please enter a search query');
                return;
            }

            const searchBtn = document.getElementById('search-btn');
            searchBtn.disabled = true;
            searchBtn.innerHTML = '<span class="loading-spinner"></span> Searching...';
            
            showStatus('info', 'Searching multiple databases for papers...');

            try {
                // Search using Crossref API first
                const response = await fetch(
                    `https://api.crossref.org/works?query=${encodeURIComponent(query)}&rows=15&select=DOI,title,author,published-print,published-online,container-title,URL,link`
                );

                if (!response.ok) throw new Error('Search failed');

                const data = await response.json();
                const papers = data.message.items.map(item => ({
                    doi: item.DOI || '',
                    title: item.title?.[0] || 'No title',
                    authors: item.author?.map(a => `${a.given || ''} ${a.family || ''}`).join(', ') || 'Unknown authors',
                    year: item['published-print']?.['date-parts']?.[0]?.[0] || 
                           item['published-online']?.['date-parts']?.[0]?.[0] || 
                           'Unknown year',
                    journal: item['container-title']?.[0] || 'Unknown journal',
                    url: item.URL || '',
                    links: item.link || []
                }));

                displaySearchResults(papers);
                showStatus('success', `Found ${papers.length} papers. Click on one to check for PDFs.`);
            } catch (error) {
                console.error('Search error:', error);
                showStatus('error', 'Search failed. Please try uploading directly.');
            } finally {
                searchBtn.disabled = false;
                searchBtn.innerHTML = 'üîç Search';
            }
        }

        // Display search results
        function displaySearchResults(papers) {
            const container = document.getElementById('search-results-container');
            if (papers.length === 0) {
                container.innerHTML = '<div class="searching-message">No papers found. Try a different search.</div>';
                return;
            }

            let html = '<div class="search-results">';
            papers.forEach((paper, index) => {
                const paperJson = JSON.stringify(paper).replace(/"/g, '&quot;');
                html += `
                    <div class="paper-item" onclick="selectPaper(${index}, ${paperJson})">
                        <div class="paper-title">${escapeHtml(paper.title)}</div>
                        <div class="paper-authors">${escapeHtml(paper.authors)}</div>
                        <div class="paper-journal">${escapeHtml(paper.journal)} ‚Ä¢ <span class="paper-year">${paper.year}</span></div>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Enhanced PDF search across multiple sources
        async function selectPaper(index, paper) {
            selectedPaper = paper;
            
            // Update UI to show selected paper
            document.querySelectorAll('.paper-item').forEach((el, i) => {
                el.classList.toggle('selected', i === index);
            });

            const selectedContainer = document.getElementById('selected-paper-container');
            selectedContainer.innerHTML = `
                <div class="selected-paper">
                    <strong>Selected:</strong> ${escapeHtml(paper.title)}
                    <div class="pdf-search-status">
                        <span class="loading-spinner"></span> Searching for PDF across multiple sources...
                    </div>
                </div>
            `;

            let pdfFound = false;
            const statusElement = selectedContainer.querySelector('.pdf-search-status');

            try {
                // Try multiple sources in order
                
                // 1. Check if DOI points to PMC
                if (paper.doi && !pdfFound) {
                    statusElement.innerHTML = '<span class="loading-spinner"></span> Checking PubMed Central...';
                    
                    // Check if it's a PMC paper
                    if (paper.doi.includes('pmc') || paper.journal.toLowerCase().includes('plos')) {
                        const pmcId = paper.doi.match(/pmc(\d+)/i)?.[1];
                        if (pmcId) {
                            pdfFound = true;
                            createPdfFromUrl(`https://www.ncbi.nlm.nih.gov/pmc/articles/PMC${pmcId}/pdf/`, paper.title);
                            statusElement.className = 'pdf-search-status pdf-found';
                            statusElement.innerHTML = '‚úÖ Found PDF on PubMed Central!';
                        }
                    }
                }

                // 2. Try arXiv
                if (!pdfFound && (paper.doi?.includes('arXiv') || paper.title.toLowerCase().includes('arxiv'))) {
                    statusElement.innerHTML = '<span class="loading-spinner"></span> Checking arXiv...';
                    
                    let arxivId = paper.doi?.match(/(\d{4}\.\d{4,5})/)?.[1];
                    if (!arxivId && paper.url) {
                        arxivId = paper.url.match(/(\d{4}\.\d{4,5})/)?.[1];
                    }
                    
                    if (arxivId) {
                        pdfFound = true;
                        createPdfFromUrl(`https://arxiv.org/pdf/${arxivId}.pdf`, paper.title);
                        statusElement.className = 'pdf-search-status pdf-found';
                        statusElement.innerHTML = '‚úÖ Found PDF on arXiv!';
                    }
                }

                // 3. Try bioRxiv/medRxiv
                if (!pdfFound && (paper.doi?.includes('biorxiv') || paper.doi?.includes('medrxiv'))) {
                    statusElement.innerHTML = '<span class="loading-spinner"></span> Checking bioRxiv/medRxiv...';
                    
                    const server = paper.doi.includes('medrxiv') ? 'medrxiv' : 'biorxiv';
                    const doiPart = paper.doi.split('/').slice(-2).join('/');
                    
                    pdfFound = true;
                    createPdfFromUrl(`https://www.${server}.org/content/${doiPart}.full.pdf`, paper.title);
                    statusElement.className = 'pdf-search-status pdf-found';
                    statusElement.innerHTML = `‚úÖ Found PDF on ${server}!`;
                }

                // 4. Try Unpaywall for open access
                if (!pdfFound && paper.doi) {
                    statusElement.innerHTML = '<span class="loading-spinner"></span> Checking Unpaywall for open access...';
                    
                    try {
                        const unpywallResponse = await fetch(
                            `https://api.unpaywall.org/v2/${paper.doi}?email=user@example.com`
                        );

                        if (unpywallResponse.ok) {
                            const data = await unpywallResponse.json();
                            if (data.is_oa && data.best_oa_location?.url_for_pdf) {
                                pdfFound = true;
                                createPdfFromUrl(data.best_oa_location.url_for_pdf, paper.title);
                                statusElement.className = 'pdf-search-status pdf-found';
                                statusElement.innerHTML = '‚úÖ Found open access PDF via Unpaywall!';
                            }
                        }
                    } catch (e) {
                        console.log('Unpaywall check failed:', e);
                    }
                }

                // 5. Try CORE API
                if (!pdfFound && paper.title) {
                    statusElement.innerHTML = '<span class="loading-spinner"></span> Checking CORE database...';
                    
                    try {
                        const coreResponse = await fetch(
                            `https://api.core.ac.uk/v3/search/works?q=${encodeURIComponent(paper.title)}&limit=1`
                        );
                        
                        if (coreResponse.ok) {
                            const coreData = await coreResponse.json();
                            if (coreData.results?.[0]?.downloadUrl) {
                                pdfFound = true;
                                createPdfFromUrl(coreData.results[0].downloadUrl, paper.title);
                                statusElement.className = 'pdf-search-status pdf-found';
                                statusElement.innerHTML = '‚úÖ Found PDF via CORE!';
                            }
                        }
                    } catch (e) {
                        console.log('CORE check failed:', e);
                    }
                }

                // 6. Try Google Scholar workaround (using title search)
                if (!pdfFound) {
                    statusElement.innerHTML = '<span class="loading-spinner"></span> Searching alternative sources...';
                    
                    // For cerebellar papers, check specific known repositories
                    if (paper.title.toLowerCase().includes('cerebellar') || 
                        paper.title.toLowerCase().includes('cerebellum')) {
                        // Many cerebellar papers are on PMC
                        const searchUrl = `https://www.ncbi.nlm.nih.gov/pmc/?term=${encodeURIComponent(paper.title)}`;
                        statusElement.className = 'pdf-search-status pdf-not-found';
                        statusElement.innerHTML = `
                            ‚ùå Could not automatically fetch PDF. 
                            <br>Try searching manually: 
                            <a href="${searchUrl}" target="_blank" style="color: #667eea;">Search PMC</a>
                            <br><small>Or use the "Upload PDF" option above.</small>
                        `;
                    } else {
                        statusElement.className = 'pdf-search-status pdf-not-found';
                        statusElement.innerHTML = `
                            ‚ùå Could not find open access PDF.
                            <br><small>Please use the "Upload PDF" option above to manually upload the paper.</small>
                        `;
                    }
                }

                // If no PDF found after all attempts
                if (!pdfFound) {
                    // Provide manual search links
                    const googleScholarUrl = `https://scholar.google.com/scholar?q=${encodeURIComponent(paper.title)}`;
                    const pmcUrl = `https://www.ncbi.nlm.nih.gov/pmc/?term=${encodeURIComponent(paper.title)}`;
                    
                    statusElement.className = 'pdf-search-status pdf-not-found';
                    statusElement.innerHTML = `
                        ‚ùå Could not automatically fetch PDF.
                        <br>Try searching manually:
                        <br><a href="${googleScholarUrl}" target="_blank" style="color: #667eea;">Google Scholar</a> | 
                        <a href="${pmcUrl}" target="_blank" style="color: #667eea;">PubMed Central</a>
                        <br><small>Then use the "Upload PDF" option above.</small>
                    `;
                }
                
            } catch (error) {
                console.error('PDF search error:', error);
                statusElement.className = 'pdf-search-status pdf-not-found';
                statusElement.innerHTML = `
                    ‚ùå Error searching for PDF.
                    <br><small>Please use the "Upload PDF" option above to manually upload the paper.</small>
                `;
            }
        }

        // Create PDF file from URL (mock for now, but provides structure for backend integration)
        function createPdfFromUrl(url, title) {
            // In a real implementation, this would fetch the PDF from the URL
            // For now, we create a mock file that contains the URL for backend processing
            const pdfContent = JSON.stringify({ url: url, title: title });
            const blob = new Blob([pdfContent], { type: 'application/pdf' });
            pdfFile = new File([blob], `${title.substring(0, 50).replace(/[^a-z0-9]/gi, '_')}.pdf`, { type: 'application/pdf' });
        }

        // Handle PDF file selection
        document.getElementById('pdf-file').addEventListener('change', function(e) {
            pdfFile = e.target.files[0];
            document.getElementById('pdf-label').textContent = pdfFile ? pdfFile.name : 'Click to select PDF file';
        });

        // Add experiment function
        function addExperiment() {
            experimentCount++;
            const container = document.getElementById('experiments-container');
            const newExp = document.createElement('div');
            newExp.className = 'experiment-item';
            newExp.setAttribute('data-exp-id', experimentCount);
            newExp.innerHTML = `
                <span style="font-weight: 600;">Experiment ${experimentCount}</span>
                <button class="remove-file" onclick="removeExperiment(${experimentCount})">‚úï</button>
                <div class="file-input-wrapper" style="margin-top: 10px;">
                    <input type="file" id="csv-${experimentCount}" class="file-input csv-input" accept=".csv" data-exp-id="${experimentCount}">
                    <label for="csv-${experimentCount}" class="file-input-label csv-label" data-exp-id="${experimentCount}">
                        Click to select CSV file
                    </label>
                </div>
            `;
            container.appendChild(newExp);
            
            // Add event listener for new CSV input
            document.getElementById(`csv-${experimentCount}`).addEventListener('change', handleCsvChange);
        }

        // Remove experiment function
        function removeExperiment(expId) {
            const element = document.querySelector(`[data-exp-id="${expId}"]`);
            if (element) {
                element.remove();
                delete csvFiles[expId];
            }
        }

        // Handle CSV file changes
        function handleCsvChange(e) {
            const expId = e.target.getAttribute('data-exp-id');
            const file = e.target.files[0];
            if (file) {
                csvFiles[expId] = file;
                document.querySelector(`.csv-label[data-exp-id="${expId}"]`).textContent = file.name;
            }
        }

        // Add event listeners to initial CSV input
        document.querySelector('.csv-input').addEventListener('change', handleCsvChange);

        // Show status message
        function showStatus(type, message) {
            const container = document.getElementById('status-container');
            container.innerHTML = `
                <div class="status-message status-${type}">
                    ${type === 'info' ? 'üîÑ' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ùå'} ${message}
                </div>
            `;
        }

        // Update progress bar
        function updateProgress(percent) {
            document.getElementById('progress-container').classList.remove('hidden');
            document.getElementById('progress-bar').style.width = percent + '%';
        }

        // Process files function with better error handling
        async function processFiles() {
            // Validation
            if (Object.keys(csvFiles).length === 0) {
                showStatus('error', 'Please select at least one CSV file');
                return;
            }

            // Get the API key
            const apiKey = getApiKey();
            if (!apiKey) {
                showStatus('error', 'API key is required. Please check your settings.');
                return;
            }

            // Disable button and show progress
            const processBtn = document.getElementById('process-btn');
            processBtn.disabled = true;
            processBtn.innerHTML = '<span class="loading-spinner"></span> Processing...';
            updateProgress(0);
            document.getElementById('results-container').innerHTML = '';

            const allResults = {
                standardized: [],
                template: null,
                readmes: []
            };

            try {
                // Step 1: Standardize CSVs
                showStatus('info', 'Step 1/3: Standardizing CSV files...');
                let csvIndex = 0;
                const csvEntries = Object.entries(csvFiles);
                
                for (const [expId, csvFile] of csvEntries) {
                    try {
                        updateProgress(Math.round((csvIndex / csvEntries.length) * 30));
                        
                        const formData = new FormData();
                        formData.append('api_key', apiKey);
                        formData.append('csv_file', csvFile);
                        if (pdfFile) {
                            formData.append('pdf_file', pdfFile);
                        }
                        
                        const response = await axios.post(`${API_URL}/api/standardize`, formData, {
                            headers: { 'Content-Type': 'multipart/form-data' },
                            timeout: 120000 // 2 minute timeout
                        });
                        
                        if (response.data.success) {
                            allResults.standardized.push({
                                experimentNumber: csvIndex + 1,
                                originalFile: csvFile.name,
                                standardizedFile: response.data.standardized_file,
                                downloadUrl: response.data.download_url,
                                report: response.data.report
                            });
                        } else {
                            console.error(`Standardization failed for ${csvFile.name}:`, response.data);
                        }
                    } catch (error) {
                        console.error(`Error standardizing ${csvFile.name}:`, error);
                        // Continue with other files even if one fails
                        showStatus('warning', `Warning: Could not standardize ${csvFile.name}. Continuing with other files...`);
                    }
                    csvIndex++;
                }

                // Step 2: Fill Template
                updateProgress(33);
                showStatus('info', 'Step 2/3: Filling OpenMotor template...');
                
                try {
                    const templateFormData = new FormData();
                    templateFormData.append('api_key', apiKey);
                    if (pdfFile) {
                        templateFormData.append('pdf_file', pdfFile);
                    }
                    
                    let formIndex = 0;
                    for (const [expId, csvFile] of csvEntries) {
                        templateFormData.append(`csv_file_${formIndex}`, csvFile);
                        formIndex++;
                    }
                    
                    const templateResponse = await axios.post(`${API_URL}/api/fill-template`, templateFormData, {
                        headers: { 'Content-Type': 'multipart/form-data' },
                        timeout: 120000
                    });
                    
                    if (templateResponse.data.success) {
                        allResults.template = {
                            outputFile: templateResponse.data.output_file,
                            experimentsProcessed: templateResponse.data.experiments_processed,
                            downloadUrl: templateResponse.data.download_url
                        };
                    }
                } catch (error) {
                    console.error('Template filling error:', error);
                    showStatus('warning', 'Warning: Could not fill template. Continuing with other tasks...');
                }

                // Step 3: Generate READMEs (only if PDF is provided)
                if (pdfFile) {
                    updateProgress(66);
                    showStatus('info', 'Step 3/3: Generating README files...');
                    
                    for (let i = 0; i < csvEntries.length; i++) {
                        try {
                            updateProgress(66 + Math.round((i / csvEntries.length) * 34));
                            
                            const readmeFormData = new FormData();
                            readmeFormData.append('api_key', apiKey);
                            readmeFormData.append('pdf_file', pdfFile);
                            readmeFormData.append('experiment_number', i + 1);
                            
                            const readmeResponse = await axios.post(`${API_URL}/api/generate-readme`, readmeFormData, {
                                headers: { 'Content-Type': 'multipart/form-data' },
                                timeout: 120000
                            });
                            
                            if (readmeResponse.data.success) {
                                allResults.readmes.push({
                                    experimentNumber: i + 1,
                                    filename: readmeResponse.data.filename,
                                    downloadUrl: readmeResponse.data.download_url
                                });
                            }
                        } catch (error) {
                            console.error(`README generation failed for Experiment ${i + 1}:`, error);
                            // Continue with other READMEs
                        }
                    }
                } else {
                    updateProgress(100);
                    showStatus('info', 'Skipping README generation (no PDF provided)');
                }

                updateProgress(100);
                
                // Check if we have any results
                if (allResults.standardized.length === 0 && !allResults.template && allResults.readmes.length === 0) {
                    showStatus('error', 'No files were successfully processed. Please check your inputs and try again.');
                } else {
                    showStatus('success', 'Processing complete! Your files are ready for download.');
                    displayResults(allResults);
                }

            } catch (error) {
                console.error('Processing error:', error);
                
                // Better error messages
                if (error.response?.status === 401) {
                    showStatus('error', 'Authentication error: Invalid API key. Please check your Anthropic API key.');
                } else if (error.response?.data?.error) {
                    showStatus('error', `Error: ${error.response.data.error}`);
                } else if (error.message) {
                    showStatus('error', `Error: ${error.message}`);
                } else {
                    showStatus('error', 'An unexpected error occurred. Please try again.');
                }
            } finally {
                processBtn.disabled = false;
                processBtn.innerHTML = 'üöÄ Process All Files';
            }
        }

        // Display results
        function displayResults(results) {
            let html = '<div class="results-section"><h3 class="results-title">üéâ Processing Complete!</h3>';
            
            // Show what was successful
            const successCount = results.standardized.length + 
                               (results.template ? 1 : 0) + 
                               results.readmes.length;
            
            if (successCount > 0) {
                html += `<p style="color: #22543d; margin-bottom: 20px;">Successfully processed ${successCount} items</p>`;
            }

            // Download all button (only if there are results)
            if (successCount > 0) {
                html += `<div style="margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick='downloadAll(${JSON.stringify(results)})'>
                        üì• Download All Files
                    </button>
                </div>`;
            }

            // Standardized CSVs
            if (results.standardized.length > 0) {
                html += '<div class="result-item"><div class="result-label">üìä Standardized CSV Files</div>';
                results.standardized.forEach(item => {
                    html += `
                        <div style="margin-top: 10px;">
                            <div class="result-value">Experiment ${item.experimentNumber}: ${escapeHtml(item.originalFile)}</div>
                            <button class="btn btn-secondary" onclick="downloadFile('${item.downloadUrl}', '${item.standardizedFile}')">
                                üì• Download Standardized CSV
                            </button>
                        </div>
                    `;
                });
                html += '</div>';
            }

            // Template
            if (results.template) {
                html += `
                    <div class="result-item">
                        <div class="result-label">üìù OpenMotor Description Template</div>
                        <div class="result-value">Processed ${results.template.experimentsProcessed} experiments</div>
                        <button class="btn btn-secondary" onclick="downloadFile('${results.template.downloadUrl}', '${results.template.outputFile}')">
                            üì• Download Template (Excel)
                        </button>
                    </div>
                `;
            }

            // READMEs
            if (results.readmes.length > 0) {
                html += '<div class="result-item"><div class="result-label">üìÑ README Files</div>';
                results.readmes.forEach(readme => {
                    html += `
                        <div style="margin-top: 10px;">
                            <div class="result-value">Experiment ${readme.experimentNumber} README</div>
                            <button class="btn btn-secondary" onclick="downloadFile('${readme.downloadUrl}', '${readme.filename}')">
                                üì• Download ${escapeHtml(readme.filename)}
                            </button>
                        </div>
                    `;
                });
                html += '</div>';
            }

            html += '</div>';
            document.getElementById('results-container').innerHTML = html;
        }

        // Download single file with better error handling
        async function downloadFile(url, filename) {
            try {
                showStatus('info', `Downloading ${filename}...`);
                const response = await axios.get(`${API_URL}${url}`, { 
                    responseType: 'blob',
                    timeout: 60000 // 1 minute timeout
                });
                
                const blob = new Blob([response.data]);
                const downloadUrl = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = downloadUrl;
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                window.URL.revokeObjectURL(downloadUrl);
                
                showStatus('success', `Downloaded ${filename}`);
            } catch (error) {
                console.error('Download error:', error);
                showStatus('error', `Error downloading ${filename}. Please try again.`);
            }
        }

        // Download all files
        async function downloadAll(results) {
            showStatus('info', 'Starting batch download...');
            let downloadCount = 0;
            let totalFiles = results.standardized.length + 
                           (results.template ? 1 : 0) + 
                           results.readmes.length;

            for (const item of results.standardized) {
                await downloadFile(item.downloadUrl, item.standardizedFile);
                await new Promise(resolve => setTimeout(resolve, 500));
                downloadCount++;
                showStatus('info', `Downloaded ${downloadCount} of ${totalFiles} files...`);
            }
            
            if (results.template) {
                await downloadFile(results.template.downloadUrl, results.template.outputFile);
                await new Promise(resolve => setTimeout(resolve, 500));
                downloadCount++;
                showStatus('info', `Downloaded ${downloadCount} of ${totalFiles} files...`);
            }
            
            for (const readme of results.readmes) {
                await downloadFile(readme.downloadUrl, readme.filename);
                await new Promise(resolve => setTimeout(resolve, 500));
                downloadCount++;
                showStatus('info', `Downloaded ${downloadCount} of ${totalFiles} files...`);
            }

            showStatus('success', `All ${totalFiles} files downloaded successfully!`);
        }

        // Initialize - clean up any stale state
        window.addEventListener('load', function() {
            // Clear any previous state
            document.getElementById('progress-container').classList.add('hidden');
            document.getElementById('status-container').innerHTML = '';
            document.getElementById('results-container').innerHTML = '';
        });
    </script>
</body>
</html>
